use std::cmp::min;
use std::process::exit;

use eframe::egui;
use eframe::egui::ScrollArea;

use super::exec::exec_command;
use super::icons::{background_load, IconCache};
use super::modules::{Entries, Mode, ModuleSearch, Settings};

/* Application */

pub struct App {
    modules: ModuleSearch,
    search: String,
    results: Option<Entries>,
    focus: usize,
    images: IconCache,
}

// application class-related functions and utilities
impl App {
    pub fn new(modes: Vec<Mode>, settings: Settings) -> Self {
        let modules = ModuleSearch::new(modes, settings).expect("module search failed");
        let mut app = Self {
            search: "".to_owned(),
            modules,
            results: None,
            focus: 0,
            images: IconCache::new(),
        };
        app.search();
        app
    }

    fn search(&mut self) {
        // assign values
        self.focus = 0;
        self.results = self.modules.search(&self.search, 0).ok();
        // load icons in background
        if let Some(results) = self.results.as_ref() {
            background_load(&mut self.images, 20, results);
        }
    }

    // shift focus based on size of results and scope of valid range
    fn shift_focus(&mut self, shift: i32) {
        // handle shifts up
        if shift < 0 {
            let change = shift.abs() as usize;
            if change > self.focus {
                self.focus = 0;
                return;
            }
            self.focus -= change;
            return;
        }
        // handle shifts down
        let max_pos = if let Some(r) = self.results.as_ref() {
            r.len() - 1
        } else {
            0
        };
        self.focus = min(self.focus + shift as usize, max_pos);
    }
}

// ui component functions
impl App {
    // implement keyboard navigation controls between menu items
    #[inline]
    fn keyboard_controls(&mut self, ctx: &egui::Context) {
        // tab/ctrl+tab controls
        if ctx.input().key_pressed(egui::Key::Tab) {
            if ctx.input().modifiers.ctrl {
                self.shift_focus(-1);
            } else {
                self.shift_focus(1);
            };
        }
        // arrow-key controls
        if ctx.input().key_pressed(egui::Key::ArrowUp) && self.focus > 0 {
            self.shift_focus(-1);
        }
        if ctx.input().key_pressed(egui::Key::ArrowDown) {
            self.shift_focus(1);
        }
        // pageup/down controls
        if ctx.input().key_pressed(egui::Key::PageUp) {
            self.shift_focus(-5);
        }
        if ctx.input().key_pressed(egui::Key::PageDown) {
            self.shift_focus(5);
        }
        // escape
        if ctx.input().key_pressed(egui::Key::Escape) {
            exit(1);
        }
        // enter - app selection
        if ctx.input().key_pressed(egui::Key::Enter) {
            let Some(results) = self.results.as_ref() else { return };
            let Some(entry) = results.get(self.focus) else { return };
            exec_command(&entry.exec, entry.terminal);
            exit(0);
        }
    }

    // implement simple topbar searchbar
    #[inline]
    fn simple_search(&mut self, ui: &mut egui::Ui) {
        let size = ui.available_size();
        ui.horizontal(|ui| {
            ui.spacing_mut().text_edit_width = size.x;
            let search = ui.text_edit_singleline(&mut self.search);
            if search.changed() {
                self.search();
            }
        });
    }

    // implement simple scrolling grid-based results panel
    fn simple_results(&mut self, ui: &mut egui::Ui) {
        let focus = self.focus;
        ScrollArea::vertical()
            .auto_shrink([false; 2])
            .show_viewport(ui, |ui, viewport| {
                // calculate top/bottom positions and size of each row
                let top_pos = viewport.min.y;
                let bottom_pos = viewport.max.y;
                let spacing = ui.spacing();
                let row_height = spacing.interact_size.y + spacing.item_spacing.y;
                // render results and their related fields
                let Some(found) = self.results.as_ref() else { return };
                let results = found.clone();
                egui::Grid::new("results")
                    .with_row_color(move |row, style| {
                        if row == focus {
                            return Some(egui::Rgba::from(style.visuals.faint_bg_color));
                        };
                        None
                    })
                    .show(ui, |ui| {
                        let has_icons = results
                            .iter()
                            .filter(|r| r.icon.is_some())
                            .peekable()
                            .peek()
                            .is_some();
                        for (n, record) in results.into_iter().enumerate() {
                            let y = n as f32 * row_height;
                            // load and render image field
                            //   content is contained within a horizontal to keep
                            //   scroll-pos from updating when icon renderings
                            //   change
                            if has_icons {
                                ui.horizontal(|ui| {
                                    // only render images that display within view window
                                    if n == 0 || (y < bottom_pos && y > top_pos) {
                                        if let Some(icon) = record.icon.as_ref() {
                                            if let Ok(image) = self.images.load(icon) {
                                                let size = egui::vec2(20.0, 20.0);
                                                image.show_size(ui, size);
                                            }
                                        }
                                        return;
                                    }
                                    ui.label("");
                                });
                            }
                            // render text fields
                            let label = ui.label(&record.name);
                            if n == self.focus {
                                label.scroll_to_me(None)
                            }
                            if let Some(extra) = record.comment.as_ref() {
                                ui.label(extra);
                            }
                            ui.end_row();
                        }
                    });
            });
    }
}

impl eframe::App for App {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        egui::CentralPanel::default().show(ctx, |ui| {
            self.keyboard_controls(ctx);
            self.simple_search(ui);
            self.simple_results(ui);
        });
    }
}
